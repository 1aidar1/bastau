// Code generated by sqlc. DO NOT EDIT.
// source: user.sql

package postgres

import (
	"context"
	"time"
)

const deleteUser = `-- name: DeleteUser :one
DELETE FROM users WHERE id = $1 RETURNING id, name, email, role, phone, password
`

func (q *Queries) DeleteUser(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRow(ctx, deleteUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Role,
		&i.Phone,
		&i.Password,
	)
	return i, err
}

const getUserByCredentials = `-- name: GetUserByCredentials :one
SELECT id, name, email, role, phone, password FROM users
    WHERE email = $1
    AND password = $2
`

type GetUserByCredentialsParams struct {
	Email    string `json:"email"`
	Password []byte `json:"password"`
}

func (q *Queries) GetUserByCredentials(ctx context.Context, arg GetUserByCredentialsParams) (User, error) {
	row := q.db.QueryRow(ctx, getUserByCredentials, arg.Email, arg.Password)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Role,
		&i.Phone,
		&i.Password,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT id, name, email, role, phone, password FROM users WHERE id = $1
`

func (q *Queries) GetUserById(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRow(ctx, getUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Role,
		&i.Phone,
		&i.Password,
	)
	return i, err
}

const getUserByToken = `-- name: GetUserByToken :one
SELECT id, name, email, role, phone, password, hash, user_id, expiry, scope FROM users INNER JOIN tokens on
    users.id = tokens.user_id
    WHERE tokens.hash = $1
    AND tokens.scope = $2
    AND tokens.expiry > $3
`

type GetUserByTokenParams struct {
	Hash   []byte      `json:"hash"`
	Scope  TokensScope `json:"scope"`
	Expiry time.Time   `json:"expiry"`
}

type GetUserByTokenRow struct {
	ID       int64       `json:"id"`
	Name     string      `json:"name"`
	Email    string      `json:"email"`
	Role     Role        `json:"role"`
	Phone    string      `json:"phone"`
	Password []byte      `json:"password"`
	Hash     []byte      `json:"hash"`
	UserID   int64       `json:"user_id"`
	Expiry   time.Time   `json:"expiry"`
	Scope    TokensScope `json:"scope"`
}

func (q *Queries) GetUserByToken(ctx context.Context, arg GetUserByTokenParams) (GetUserByTokenRow, error) {
	row := q.db.QueryRow(ctx, getUserByToken, arg.Hash, arg.Scope, arg.Expiry)
	var i GetUserByTokenRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Role,
		&i.Phone,
		&i.Password,
		&i.Hash,
		&i.UserID,
		&i.Expiry,
		&i.Scope,
	)
	return i, err
}

const registerUser = `-- name: RegisterUser :one
INSERT INTO users
    (name, email, role, phone,password)
    VALUES
    ($1,$2,$3,$4,$5)
    RETURNING id
`

type RegisterUserParams struct {
	Name     string `json:"name"`
	Email    string `json:"email"`
	Role     Role   `json:"role"`
	Phone    string `json:"phone"`
	Password []byte `json:"password"`
}

func (q *Queries) RegisterUser(ctx context.Context, arg RegisterUserParams) (int64, error) {
	row := q.db.QueryRow(ctx, registerUser,
		arg.Name,
		arg.Email,
		arg.Role,
		arg.Phone,
		arg.Password,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}
